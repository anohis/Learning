# The C# job system
job system 提供簡單有效的方法來編寫多執行緒程式碼  
- job system 維護一個工作執行緒池，每個額外的核心都有一個 worker thread (例如一個八核心上有 1 個 main thread 和 7 個 worker thread)
- worker thread 的執行單元稱作 job，當 worker thread 閒置時，他會從 job queue 取得一個 job 執行
- 一個 job 只要在一個 worker thread 上被執行，就會直到結束為止，也就是說一個 job 不會被搶占

```C#
// A simple example job that multiplies the
// elements of two arrays.
// Implementing IJob makes this struct a job type.
struct MyJob : IJob
{
    // A NativeArray is “unmanaged”, meaning it
    // isn’t garbage collected.
    public NativeArray<float> Input;
    public NativeArray<float> Output;
    // The Execute method is called when the
    // job system executes this job.
    public void Execute()
    {
        // Multiply every value in Output by the
        // corresponding value in the Input array.
        for (int i = 0; i < Input.Length; i++)
        {
            Output[i] *= Input[i];
        }
    }
}

var job = new MyJob();
JobHandle handle = job.Schedule();
handle.Complete();
```

### 安排和完成 job
- 一個 job 只能在 main thread 進入排程，不能從其他的 job
- 只有在 main thread 可以呼叫 JobHandle.Complete()，且一旦呼叫就會導致阻塞，直到 job 完成
- 一個 job 結束後，可以保證其上面的資料是安全的

### 安全檢查和依賴性
- 為了確保隔離，每個 job 都有私有的資料，main thread 和其他 job 不能訪問
- 如果多個 job 共享相同資料且並行會導致 Race Conditions，因此當排程一個可能造成衝突的 job 時，安全檢查會拋出例外
- 在排程一個 job 時，可以宣告依賴的 job，此時 job 會等到依賴的 job 完成後才會執行
- 完成一個 job 表示其直接或間接依賴的 job 也是完成的
> [!NOTE]
> 只要有 "可能" Race Conditions 就會拋出例外
> ```C#
> NativeArray<float> data = new NativeArray<float>(10, Allocator.TempJob);
> var jobA = new JobA { Data = data };  
> JobHandle handleA = jobA.Schedule();  
> var jobB = new JobB { Data = data };  
> JobHandle handleB = jobB.Schedule(); // throw InvalidOperationException
> handleA.Complete();  
> handleB.Complete();  
> data.Dispose();  
> ```
> 正確方式
> ```C#
> JobHandle handleB = jobB.Schedule(handleA);  
> ```
