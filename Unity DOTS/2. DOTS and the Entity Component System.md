# The C# job system
job system 提供簡單有效的方法來編寫多執行緒程式碼  
- job system 維護一個工作執行緒池，每個額外的核心都有一個 worker thread (例如一個八核心上有 1 個 main thread 和 7 個 worker thread)
- worker thread 的執行單元稱作 job，當 worker thread 閒置時，他會從 job queue 取得一個 job 執行
- 一個 job 只要在一個 worker thread 上被執行，就會直到結束為止，也就是說一個 job 不會被搶占

```C#
// A simple example job that multiplies the
// elements of two arrays.
// Implementing IJob makes this struct a job type.
struct MyJob : IJob
{
    // A NativeArray is “unmanaged”, meaning it
    // isn’t garbage collected.
    public NativeArray<float> Input;
    public NativeArray<float> Output;
    // The Execute method is called when the
    // job system executes this job.
    public void Execute()
    {
        // Multiply every value in Output by the
        // corresponding value in the Input array.
        for (int i = 0; i < Input.Length; i++)
        {
            Output[i] *= Input[i];
        }
    }
}

var job = new MyJob();
JobHandle handle = job.Schedule();
handle.Complete();
```

### 安排和完成 job
- 一個 job 只能在 main thread 進入排程，不能從其他的 job
- 只有在 main thread 可以呼叫 JobHandle.Complete()，且一旦呼叫就會導致阻塞，直到 job 完成
- 一個 job 結束後，可以保證其上面的資料是安全的

### 安全檢查和依賴性
- 為了確保隔離，每個 job 都有私有的資料，main thread 和其他 job 不能訪問
- 如果多個 job 共享相同資料且並行會導致 Race Conditions，因此當排程一個可能造成衝突的 job 時，安全檢查會拋出例外
- 在排程一個 job 時，可以宣告依賴的 job，此時 job 會等到依賴的 job 完成後才會執行
- 完成一個 job 表示其直接或間接依賴的 job 也是完成的
> [!NOTE]
> 只要有 "可能" Race Conditions 就會拋出例外
> ```C#
> NativeArray<float> data = new NativeArray<float>(10, Allocator.TempJob);
> var jobA = new JobA { Data = data };  
> JobHandle handleA = jobA.Schedule();  
> var jobB = new JobB { Data = data };  
> JobHandle handleB = jobB.Schedule(); // throw InvalidOperationException
> handleA.Complete();  
> handleB.Complete();  
> data.Dispose();  
> ```
> 正確方式
> ```C#
> JobHandle handleB = jobB.Schedule(handleA);  
> ```

> [!NOTE]
> Unity 不少 API 是使用 job 實現的，因此在 profiler 中也許可以看到

> [!NOTE]
> job 一般不會用在 IO 和網路傳輸，例如讀寫檔案  
> 因為通常這些操作會阻塞執行緒  
> 對於這類的需求請用異步或傳統的 C# 多執行緒功能

# The Burst compiler
Burst compiler 提供第三種編譯方案，專為資料導向 (DoD) 和 job system 優化   
在重度計算的情況下執行效率會比 Mono 或 IL2CPP 更好  
但僅可以編譯一小部分的 C#，大部分 C# 無法被編譯  
最大的限制是無法訪問託管物件 (Managed object)

```C#
// The BurstCompile attribute marks this job to be Burst-compiled.
[BurstCompile]
struct MyJob : IJob
{
    public void Execute()
    {
    }
}
```

Burst 的效能提升主要來自於以下幾個技術  
- SIMD（單指令多資料）：這是一種能夠同時對多個資料元素執行相同操作的技術，大幅提高處理效率
- 更佳的別名分析（aliasing awareness）：當兩個或多個指標或參考指向相同的記憶體位置時，稱為別名。Burst 更能正確理解這些情況，進而做出更有效的最佳化

# Collections
提供非託管的集合結構，例如 list，這些結構針對 job、Burst 進行優化  
由於非託管因此需要主動呼叫 Dispose() 釋放資源  
集合的型別可以區分為以下
- 以 Native 開頭命名的型別會執行安全檢查，當遇到以下情況會拋出例外
  - 如果沒有 Dispose
  - 如果在 job 中以非執行緒安全的方式使用
- 以 Unsafe 開頭命名的型別不會執行安全檢查
- 剩下的型別都是小型結構，沒有指針因此也不需要分配與釋放，也不存在多執行緒安全問題

> [!NOTE]
> 通常 native 型別都有等價的 unsafe 型別，例如 NativeList 和 UnsafeList  
> 但基於安全考量，建議使用 native 型別
